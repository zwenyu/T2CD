#! /usr/bin/Rscript

# set working directory as T2CD

# simulations to test accuracy of estimating d and tau, include computation time
# regime 1 generated by gp

library(parallel)
source('./helperfunction/helperfn.R')
source('./helperfunction/competingmethods.R')
source('./method/t2cd_step.mv.R')
source('./method/t2cd_sigmoid.mv.R')

### setup

args = commandArgs(trailingOnly = TRUE) 
# TRUE/FALSE for hetero1 (heteroscedastic noise for regime 1) in sim.simple()
# p dimension
if (length(args) > 0){
  hetero1 = args[1]
  p = as.numeric(args[2])
}else{
  hetero1 = TRUE
  p = 3
}

simnum = 100

d_list = seq(-0.45, 1.45, by = 0.2)
tau_list = seq(15, 45, by = 5)
taupercent_list = tau_list/70
truetau_list = tau_list
tau.percent = c(taupercent_list[1], taupercent_list[7], taupercent_list[3])
true.tau = c(truetau_list[1], truetau_list[7], truetau_list[3])

# Calculate the number of cores
no_cores = detectCores() - 1
# Initiate cluster
outfilename = paste('./Simulations/Multivariate/mvsim', p, '.txt', sep = '')
cl = makeCluster(no_cores, type = 'FORK', outfile = outfilename)
# each iteration of function output as a list entry
# each function output is a named list

cpt_k = function(k){
  print(k)
  tauN = 3
  dN = length(d_list)
  
  tau_step = tau_sigmoid = tau_ecp = tau_ecp.diff = 
    d_univ_step = d_univ_sigmoid = d_univ_ecp = d_univ_ecp.diff = d_univ_seg = d_univ_truetau =  
    matrix(NA, dN, tauN, dimnames = list(d_list, true.tau))
  
  d_step = ptime_step =
    d_sigmoid = ptime_sigmoid = 
    d_ecp = ptime_ecp = 
    d_ecp.diff = ptime_ecp.diff = 
    d_seg = ptime_seg = 
    d_truetau = ptime_truetau = 
    matrix(NA, dN, 1, dimnames = list(d_list))
  
  for (i in 1:dN){
    sim_ij = sim.simple(tau.percent=tau.percent,  d=d_list[i], p = p, 
                        hetero1=hetero1, regime1='gp', seed=k)

    # T2CD-step
    s = proc.time()
    res_step = t2cd_step.mv(sim_ij, t.max = 70, use_arf = F)
    ptime = proc.time() - s
    tau_step[i,] = res_step$tau
    d_univ_step[i,] = res_step$univ_d
    d_step[i] = res_step$d
    ptime_step[i] = ptime[1]

    # T2CD-sigmoid
    s = proc.time()
    res_sigmoid = t2cd_sigmoid.mv(sim_ij, t.max = 70)
    ptime = proc.time() - s
    tau_sigmoid[i,] = res_sigmoid$tau
    d_univ_sigmoid[i,] = res_sigmoid$univ_d
    d_sigmoid[i] = res_sigmoid$d
    ptime_sigmoid[i] = ptime[1]
    
    # ecp, original
    s = proc.time()
    res_ecp = ecp_d.mv(sim_ij, dflag = 'original')
    ptime = proc.time() - s
    tau_ecp[i,] = res_ecp$tau
    d_univ_ecp[i,] = res_ecp$univ_d
    d_ecp[i] = res_ecp$d
    ptime_ecp[i] = ptime[1]
    
    # ecp, diff
    s = proc.time()
    res_ecp.diff = ecp_d.mv(sim_ij, dflag = 'diff')
    ptime = proc.time() - s
    tau_ecp.diff[i,] = res_ecp.diff$tau
    d_univ_ecp.diff[i,] = res_ecp.diff$univ_d
    d_ecp.diff[i] = res_ecp.diff$d
    ptime_ecp.diff[i] = ptime[1]
    
    # segmented at fixed tau
    s = proc.time()
    res_seg = estd.mv(sim_ij, tau = rep(50, p))
    ptime = proc.time() - s
    d_univ_seg[i,] = res_seg$univ_d
    d_seg[i] = res_seg$d
    ptime_seg[i] = ptime[1]
    
    # segmented with true tau
    s = proc.time()
    res_truetau = estd.mv(sim_ij, tau = true.tau)
    ptime = proc.time() - s
    d_univ_truetau[i,] = res_truetau$univ_d
    d_truetau[i] = res_truetau$d
    ptime_truetau[i,] = ptime[1]
  }
  return(list(tau_step = tau_step, d_univ_step = d_univ_step, d_step = d_step, ptime_step = ptime_step,
              tau_sigmoid = tau_sigmoid, d_univ_sigmoid = d_univ_sigmoid, d_sigmoid = d_sigmoid, ptime_sigmoid = ptime_sigmoid,
              tau_ecp = tau_ecp, d_univ_ecp = d_univ_ecp, d_ecp = d_ecp, ptime_ecp = ptime_ecp,
              tau_ecp.diff = tau_ecp.diff, d_univ_ecp.diff = d_univ_ecp.diff, d_ecp.diff = d_ecp.diff, ptime_ecp.diff = ptime_ecp.diff,
              d_univ_seg = d_univ_seg, d_seg = d_seg, ptime_seg = ptime_seg,
              d_univ_truetau = d_univ_truetau, d_truetau = d_truetau, ptime_truetau = ptime_truetau))
}

cptresults_comp = parLapply(cl, 1:simnum, cpt_k)

save.image(paste('./Simulations/Multivariate/simulate_mv', hetero1, p,'.RData',
                 sep = ''))
stopCluster(cl)
